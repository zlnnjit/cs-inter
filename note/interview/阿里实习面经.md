> 拿到 **阿里实习offer**，**经历了5次面试**，其中4轮技术面，1轮HR面试。在这里分享一下自己的面试经验和学习总结。希望能够帮助更多的小伙伴。
>
> 
>
> 我本科毕业于中南大学信管专业，真正开始学习Java是在大三下学期，研究生就读北航的移动云计算专业。刚开始也是小白，也是一步步成成起来的。需要提的一点是，**你将来是需要靠这个吃饭的，所以请对找工作保持十二分的热情，而且越早准备越好。**



## 一面

一面是在上午9点多接到支付宝的面试电话的，因为很期望能够尽快接到阿里的电话，所以非常兴奋。电话接通之后还是非常紧张的，毕竟是第一次这样的面试。

### synchronized与Lock的区别，使用场景。看过synchronized的源码没

**1.synchronized与Lock的区别**

synchronized<--->Lock

+ JVM<--->API
+ 可重入
+ 非公平锁<--->公平锁/非公平锁
+ 不可判断，等待可中断<--->可判断，等待可中断
+ 等待/通知机制<--->可实现选择性通知（锁可以绑定多个条件）

参考：[京东18届一年半经验社招.md#synchronized和lock的区别必考](https://github.com/zlnnjit/cs-inter/blob/master/note/interview/京东18届一年半经验社招.md#synchronized和lock的区别必考)



**2.synchronized与Lock的使用场景**

一般情况下两个都可以使用，这时候推荐使用synchronized，原因是虚拟机在未来的性能改进中会更偏向于原生的synchronized，但是在特殊场景下需要考虑使用Lock:

+ 等待可中断；
+ 公平锁
+ 选择性通知



**3.synchronized源码的了解**

推荐阅读：

[深入分析Synchronized原理(阿里面试题)](https://www.cnblogs.com/aspirant/p/11470858.html)

[「阿里面试系列」分析Synchronized原理，让面试官仰望](<https://blog.csdn.net/javaxuexi123/article/details/85056588>)



### JVM自动内存管理，Minor GC与Full GC的触发机制

**1.JVM自动内存管理**

**①哪些内存需要回收？**

不可能再被任何途径使用的对象需要被回收。



**②怎么判断内存是够能够回收？**

+ **引用计数法**：给对象维护一个计数器，每次被引用计数器的值+1，每次引用被释放，计数器的值-1，当计数器的值为0时，认为它不可能再被引用了。
+ **可达性分析**：从GCRoots向下搜索，走过的路径为引用链，当一个对象到GCRoots没有任何引用链相连则证明对象不可用。

由于引用计数法很难解决对象循环引用的场景，因此一般都使用可达性分析来判断一个对象是否存活。



**③什么时候回收？**

+ **新生代的回收时机**

  新的对象需要在Eden区申请内存，但Eden区没有足够的连续的空间分配给对象会触发一次minor GC

+ **老年代的回收时机**

  从新生代过来的对象需要在老年代申请空间，但老年代没有足够的连续的空间来分配，会触发一次major GC。

  HotSpot VM 老年代给新生代做空间担保时，若老年代连续可用空间小于历次晋升到老年代对象的平均大小，触发一次major GC。

  

**④如何回收？**

+ 回收算法
  + 参考[京东18届一年半经验社招.md#垃圾回收算法必考](https://github.com/zlnnjit/cs-inter/blob/master/note/interview/京东18届一年半经验社招.md#垃圾回收算法必考)

+ 垃圾回收器
  + 参考[京东18届一年半经验社招.md#各垃圾回收器的特点及区别](https://github.com/zlnnjit/cs-inter/blob/master/note/interview/京东18届一年半经验社招.md#各垃圾回收器的特点及区别)

推荐阅读：

[JVM自动内存管理机制](https://www.cnblogs.com/trybestme/p/7489787.html)



**2.Minor GC与Full GC的触发机制**

参考[京东18届一年半经验社招.md#minor-gc和full-gc触发条件](https://github.com/zlnnjit/cs-inter/blob/master/note/interview/京东18届一年半经验社招.md#minor-gc和full-gc触发条件)







### 了解过JVM调优没，基本思路是什么

**第一步：JVM性能定义**

+ 吞吐量：重要指标之一，是指不考虑垃圾收集引起的停顿时间或内存消耗，垃圾收集器能支撑应用达到的最高性能指标。
+ 延迟：其度量标准是缩短由于垃圾收集引起的停顿时间或者完全消除因垃圾收集所引起的停顿，避免应用运行时发生抖动。
+ 内存占用：垃圾收集器流畅运行所需要的内存数量。

**第二步：JVM性能调优原则**

+ MinorGC回收原则： 每次minor GC 都要尽可能多的收集垃圾对象。以减少应用程序发生Full GC的频率。

+ GC内存最大化原则：处理吞吐量和延迟问题时候，垃圾处理器能使用的内存越大，垃圾收集的效果越好，应用程序也会越来越流畅。

+ GC调优3选2原则: 在性能属性里面，吞吐量、延迟、内存占用，我们只能选择其中两个进行调优，不可三者兼得。

**第三步：进行调优**

+ 内存占用调优
  + jvm内存分配&参数
  + 计算活跃数据大小
+ 延迟调优
  + 优化新生代的大小
  + 优化老年代的大小

+ 吞吐量调优
  + 选择合适的垃圾收集器
  + 进行吞吐量测试，并内存占用调优和延迟调优进行微调。

推荐阅读：

[如何合理的规划一次jvm性能调优](https://juejin.im/post/59f02f406fb9a0451869f01c)

[JVM 调优方法](https://blog.csdn.net/weixin_39593985/article/details/90414392)



### 如何设计存储海量数据的存储系统

+ 实时计算+离线计算
+ 索引
  + 全文检索框架solr（前台）+ elasticsearch（后台）进行数据索引

- 存储形式
  - 基础数据存储：MySQL
  - 文本存储：mongodb
  - 热点数据：Redis
- 数据容灾与高可用

推荐阅读：

[京东评价系统海量数据存储设计](https://www.jianshu.com/p/b65ed1613b0f)





### 缓存的实现原理，设计缓存要注意什么

①确认是否需要缓存

+ 某个结果需要大量的CPU计算
+ 数据库IO比较繁忙

②本地缓存选择

+ **ConcurrentHashMap**：比较适合缓存比较固定不变的元素，且缓存的数量较小的
+ **LRUMap**：如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。
+ **Ehcache**：由于其jar包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择Ehcache。
+ **Guava Cache**：其本身是轻量级的而且功能较为丰富
+ **Caffeine**：其在命中率，读写性能上都比Guava Cache好很多，并且其API和Guava cache基本一致，甚至会多一点。

③分布式缓存

+ **MemCache**：其吞吐量较大，但是支持的数据结构较少，并且不支持持久化。
+ **Squirrel/Redis**：支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。
+  **Cellar/Tair**：支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。

④多级缓存

+ 进程内缓存
+ 多级缓存

⑤缓存更新

+ 先删除缓存，再更新数据库
+ 先更新数据库，再删除缓存

⑥缓存问题

+ 缓存穿透（不存在的数据直接访问数据库）
+ 缓存击穿（热点数据过期）
+ 缓存雪崩（同一时间过期多个数据）

⑦缓存监控

推荐阅读：

[如何优雅的设计和使用缓存？](https://juejin.im/post/5b849878e51d4538c77a974a#heading-0)

[设计缓存架构时的一些注意事项](https://segmentfault.com/a/1190000009576474)



### 淘宝热门商品信息在JVM哪个内存区域

一般来说，热门商品信息存放在分布式缓存中，在JVM中一般存放在堆中。





### 操作系统的页式存储

把内存中的物理地址空间和程序中的逻辑地址空间各分成若干个大小相等的块，逻辑空间中的块称为页面，物理空间中的块称为物理块。



页式存储管理的优点是将作业的连续逻辑地址空间划分成页，可以分配到内存中不连续的块中，也就是分配到内存的不连续的主存区域中，并且能使作业正确的执行，这样进一步的提高了主存空间的利用率。缺点是当处理器处理一个作业时，必须访问两次主存，第一次是访问页表从而找到页号所对应的块号，然后换算出作业的绝对地址，第二次是处理器再按照换算出程序在主存中的绝地地址再进行运算操作。

推荐阅读

[操作系统的页式存储](https://blog.csdn.net/zhoukun1008/article/details/45291343)



### volatile关键字的如何保证内存可见性

被`volatile`关键字修饰的变量，在每个写操作之后，都会加入一条`store`内存屏障命令，此命令强制工作内存将此变量的最新值保存至主内存；在每个读操作之前，都会加入一条`load`内存屏障命令，此命令强制工作内存从主内存中加载此变量的最新值至工作内存。



### happens-before原则

①happens-before含义：**前面一个操作的结果对后续操作是可见的**。

+ 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

+ 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

  

②happens-before原则

+ **程序的顺序性规则**：在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。
  + 理解：同一个线程中前面的所有写操作对后面的操作可见
+ **管程中锁的规则**：这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。
  + 理解：如果线程1写入了volatile变量v（临界资源），接着线程2读取了v，那么，线程1写入v及之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）
+ **volatile变量规则**：对一个volatile变量的写操作happen—before后面（时间上）对该变量的读操作。
  + 理解：如果线程1写入了volatile变量v（临界资源），接着线程2读取了v，那么，线程1写入v及之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）
+ **线程启动 start() 规则**：它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
  + 理解：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A在对变量修改线程B未必可见。
+ **线程终止 join() 规则**：这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对**共享变量**的操作。
  + 理解：线程t1写入的所有变量，在任意其它线程t2调用t1.join()，或者t1.isAlive() 成功返回后，都对t2可见。
+ **线程中断interrupt()规则**：对线程interrupt()的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。
  + 理解：线程t1写入的所有变量，调用Thread.interrupt()，被打断的线程t2，可以看到t1的全部操作
+ **对象终结finalize()规则**：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize()方法的开始。
  + 理解：对象调用finalize()方法时，对象初始化完成的任意操作，同步到全部主存同步到全部cache。

+ **传递性规则：**如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。

推荐阅读：

[【并发重要原则】happens-before理解和应用](https://www.jianshu.com/p/b9186dbebe8e)



### Lucene全文搜索的原理

推荐阅读：

[lucene 全文检索原理和流程](https://www.jianshu.com/p/0cfe042412a2)



### 你觉得自己适合哪方面的开发，为什么



### 想去哪里实习，杭州？



### 反问面试官的问题：

- 评价一下我的这次面试表现

- 应该在我的技术栈中增加什么

- 有机会下次面试吗

  

---

**一面总结** 

一面大概面了50多分钟，从面试官口中得知他是一个老员工，比我大不了多少，总体上还是聊得蛮投机的。最后的三个问题是我问面试官的，在回答我是否还有机会下次面试的时候说：**竞争很激烈，不过机会还是有的**。

可以看出一面的问题不是很难，但是要得到面试官比较高的评价，还是需要一定的表达能力和对技术比较本质的认识的，**如果在回答问题的时候能够做一些适当的扩展，自然会让面试官对你有不一样的评价**。



我回答问题的遵循一定的步骤：**先回答问题本质，在回答具体细节，最后做一些平时编程中的扩展**。这样，会让面试官觉得你确实是在这个技术上面下过功夫的。



## 二面

等了将近6天（还以为被刷了呢）终于在第二周的周四接到阿里面试电话，那叫一个激动啊。赶紧找了一个安静的地方，准备好后开始正式面试。二面的面试官是一个部门主管，自然还是有点小紧张的。**这次面试官上来就直接问，没有一面的面试官那么好说话。**



### 自我介绍下自己，不超过3分钟（我的自我介绍仍然不超过1分钟）



### 你说你熟悉并发编程，那么你说说Java锁有哪些种类，以及区别（果然深度不一样）

+ 乐观锁/悲观锁
  + **乐观锁：**每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用**版本号**等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**(Compare and Swap 比较并交换)实现的。
  + **悲观锁**：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。
+ 独享锁/共享锁（具体实现互斥锁/读写锁）
  + **独享锁：**指该锁一次只能被一个线程所持有。例如ReentrantLock。
  + **共享锁：**指该锁可被多个线程所持有。ReadWriteLock其读锁是共享锁，其写锁是独享锁。
+ **可重入锁：**可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。ReetrantLock/Synchronized均为可重入锁。
+ 公平锁/非公平锁
  + **公平锁：**多个线程按照申请锁的顺序来获取锁。ReetrantLock可以设置为公平锁（默认非公平锁）。
  + **非公平锁：**多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。Synchronized而言，也是一种非公平锁。

+ **分段锁**：是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
+ 偏向锁/轻量级锁/重量级锁
  + **偏向锁：**一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
  + **轻量级锁：**当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
  + **重量级锁：**当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
+ **自旋锁：**在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

推荐阅读：

[Java中的锁分类与使用](https://www.cnblogs.com/hustzzl/p/9343797.html)







如何保证内存可见性

- Http请求的过程与原理
- TCP连接的特点
- TCP连接如何保证安全可靠的
- 为什么TCP连接需要三次握手，两次不可以吗，为什么
- AOP的原理
- 动态代理与cglib实现的区别
- 说说代理的实现原理
- 看过Spring源码没，说说Ioc容器的加载过程吧
- 了解过字节码的编译过程吗







> <https://mp.weixin.qq.com/s?__biz=MzU4NzYwNDAwMg==&mid=2247486966&idx=1&sn=54fff14fd8c17ecf1dcc0e6bbc9f4014&chksm=fde8c4bbca9f4dad74aae5d677d588a559e40ba4d32ed3753a399ce16ac674e09617de7125fe&mpshare=1&scene=23&srcid=&sharer_sharetime=1587735553765&sharer_shareid=ee3324a57034fb2f709c80c31b4d4fa6#rd>

